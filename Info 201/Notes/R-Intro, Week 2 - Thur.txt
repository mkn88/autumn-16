R-Intro
Info 201 Week 2, Thursday, R-Intro

Module 5 - Basic Syntax

	Store info in a variable by assigning that variable a value
    	
		x <- 6
  
  	Supports mathematical operations
    	
		hours.in.a.week <- 24 * 7
  
  	Execute code in RStudio by 
    	
		ctrl + enter

Module 5 - Basic Data Types

	Numeric: default computational data type, all real numbers and fractions
    	
		temperature <- 66.4

	Character: strings of characters in a variable, made with single or double quotes
    	
		name <- 'Mike' # "Mike" would be the same

	Boolean: Logical values, if something is TRUE or FALSE
    	
		equality <- 3 > 2 # stores TRUE, not in quotes

	Also complex (complex.variable <- 2i) and integer (my.integer <- 2L) data types, though less often used (see module)

	Documentation: R's documentation is actually quite good compared to other programming languages. Functionalities are 
	all described in the same format, and often contain a helpful example. To search the documentation within R, simply 
	type ? followed by the function name you're using (more on functions coming soon). You can also search the documentation 
	by typing two questions marks (??SEARCH).

Module 6 - Functions

	To learn about function inputs/outputs, see the documentation of that function by entering ?FunctionName into your RStudio console.

Module 6 - Built-in Functions

	To execute a function, type the function name, and pass (comma-separated)
  	arguments into parentheses:
    	
		FunctionName(argument)

	You can store the results of a function in a variable

		result <- FunctionName(argument)

Module 6 - Loading Functions

	First, you’ll need to download an R package (only once)

		install.packages("stringr")

	Each time you want to use the package, you’ll need to load it into R
		
		library(stringr)

	When you load a package, you may receive a warning message about the package being built under a previous version of R. In all 
	likelihood, this shouldn't cause a problem, but you should pay attention to the details of the messages, and keep them in mind 
	(especially if you start getting unexpected errors). After loading the package with the library function, you have access to 
	functions that were written as part of that package.

Module 6 - Writing Functions

	Write a function to add two numbers together
			
			# Argument/Parameters inside parentheses
		AddNumbers <- function(a, b) {
			# Function body: perform tasks in here
		answer <- a + b
			# Return statement: what you want the function to output
		return (answer)

	Execute your AddNumbers function with the values 3 and 6
	
		AddNumbers(3,6)  # 9

Module 6 - Conditional Statements

		if(SOMETHING IS TRUE) {
	  	# DO EVERYTHING IN HERE
		} else {
		  # OTHERWISE, DO EVERYTHING IN HERE
		}
	In order to execute a conditional statement, the value inside of the if() parentheses must return a boolean value (or must resolve 
	to a boolean value). Note, you can provide multiple different conditions if you use the elseif() syntax throughout this process:

		if(SOMETHING IS TRUE) {
	 	# DO EVERYTHING IN HERE
		} else if(SOMETHING ELSE IS TRUE) {
		  # DO EVERYTHING IN HERE
		} else {
		  # BY DEFAULT, DO EVERYTHING IN HERE
		}

Module 7 - Vectors

	Use the combine (`c`) function to create a vector.

		people <- c('Sarah', 'Arup')
		print(people)  # [1] "Sarah" "Arup"

---

	Use the combine (`c`) function to create a vector.

		people <- c('Sarah', 'Arup')

 	Then use the combine (`c`) function to combine the `people` vector and the name 'Josh'.
	
		more.people <- c(people, 'Josh')
		print(more.people)  # [1] "Sarah" "Arup" "Josh"

Module 7 - Vector Indexing - Position Indexing

	Use the combine (`c`) function to create a vector.
		
		people <- c('Sarah', 'Arup')

	Then store the second element in the `people` vector in a variable `person2`

		person2 <- people[2]
		print(person2)  #[1] "Arup"

---

	If you pass a negative-index into the square-brackets, R will return all elements except the (negative) index specified.

	Create a `colors` vector

		colors <- c('yellow', 'blue', 'orange')

	Return all elements except the second index

		all.but.blue <- colors[-2]  # returns 'yellow', 'orange'

---


	Passing a out-of-range value into the square brackets will return NA, which stands for Not Available:

	Create a vector x

		x <- c(1,2,3)

	Attempt to access the 10th element

		x[10]  # returns NA

Module 7 - Vector Indexing - Multiple Indices

	As you can imagine, you may want to access multiple elements inside of a vector. 
	To do so, you can pass a vector of indices into your square brackets:

	Create a `colors` vector

		colors <- c('yellow', 'blue', 'orange')

	Retrieve the second and third elements from the `colors` vector

		colors[c(2, 3)]

---

	Recall the seq function from module-6 which produced a sequence of numbers. 
	A handy shorthand for the sequence function is the colon operator (a:b), which returns 
	a vector from a to b (incrementing by 1). This allows you to write nicely readable code such as this:

	Create a `colors` vector

		colors <- c('yellow', 'blue', 'orange', 'green', 'black')

	Retrieve values in positions 2 through 5
		
		colors[2:5]

Module 7 - Vector Indexing - Logical Indices

	Create a vector of shoe sizes

		shoe.sizes <- c(7, 6.5, 4, 11, 8)
	
	Use a vector of boolean values to retrieve the first, fourth, and fifth elements

		shoe.sizes[c(TRUE, FALSE, FALSE, TRUE, TRUE)] # returns 7, 11, 8
	
	Better yet, create a boolean vector that indicates if a shoe size is greater than 6.5, then use that

		shoe.is.big <- shoe.sizes > 6.5 # returns T, F, F, T, T
	
	Use the `shoe.is.big` vector to select large shoes

		big.shoes <- shoe.sizes[shoe.is.big] # returns 7, 11, 8

	Even better, do it all at once!

		shoe.sizes[shoe.sizes > 6.5] # returns 7, 11, 8

Module 7 - Vector Indexing - 

